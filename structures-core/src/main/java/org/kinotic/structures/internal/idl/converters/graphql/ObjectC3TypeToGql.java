package org.kinotic.structures.internal.idl.converters.graphql;

import com.apollographql.federation.graphqljava.FederationDirectives;
import graphql.Scalars;
import graphql.language.BooleanValue;
import graphql.schema.*;
import org.apache.commons.lang3.tuple.Pair;
import org.kinotic.continuum.idl.api.converter.C3ConversionContext;
import org.kinotic.continuum.idl.api.converter.C3TypeConverter;
import org.kinotic.continuum.idl.api.converter.Cacheable;
import org.kinotic.continuum.idl.api.schema.C3Type;
import org.kinotic.continuum.idl.api.schema.ObjectC3Type;
import org.kinotic.continuum.idl.api.schema.PropertyDefinition;
import org.kinotic.continuum.idl.api.schema.decorators.NotNullC3Decorator;
import org.kinotic.structures.api.domain.idl.decorators.*;
import org.kinotic.structures.internal.endpoints.graphql.DiscriminatorTypeResolver;
import org.kinotic.structures.internal.utils.GqlUtils;

import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition;
import static graphql.schema.GraphQLInputObjectField.newInputObjectField;
import static graphql.schema.GraphQLInputObjectType.newInputObject;
import static graphql.schema.GraphQLNonNull.nonNull;
import static graphql.schema.GraphQLObjectType.newObject;
import static graphql.schema.GraphQLTypeReference.typeRef;
/**
 * Created by NavÃ­d Mitchell ðŸ¤ª on 5/2/23.
 */
public class ObjectC3TypeToGql implements C3TypeConverter<GqlTypeHolder, ObjectC3Type, GqlConversionState>, Cacheable {


    @Override
    public GqlTypeHolder convert(ObjectC3Type objectC3Type,
                                 C3ConversionContext<GqlTypeHolder, GqlConversionState> conversionContext) {

        GraphQLObjectType.Builder outputBuilder = newObject().name(objectC3Type.getName());
        GraphQLInputObjectType.Builder inputBuilder = newInputObject().name(objectC3Type.getName() + "Input");
        boolean nullInputTypeFound = false;

        // Process decorators on the object
        PolicyDecorator policyDecorator = objectC3Type.findDecorator(PolicyDecorator.class);
        if(policyDecorator != null){
            outputBuilder.withDirective(GqlUtils.policy(policyDecorator.getPolicies()));
        }

        for (PropertyDefinition property : objectC3Type.getProperties()) {

            String fieldName = property.getName();
            C3Type type = property.getType();

            conversionContext.state().beginProcessingField(property);

            GqlTypeHolder fieldValue;

            if(property.hasDecorators()
                    && (property.containsDecorator(IdDecorator.class) || property.containsDecorator(AutoGeneratedIdDecorator.class))){

                fieldValue = new GqlTypeHolder(GraphQLNonNull.nonNull(Scalars.GraphQLID), GraphQLNonNull.nonNull(Scalars.GraphQLID));

                // Add the @key directive to the field if federated
                // We set resolvable to false if only one field exists.
                // This is to support referencing an entity without contributing fields
                // https://www.apollographql.com/docs/graphos/schema-design/federated-schemas/entities/contribute-fields#referencing-an-entity-without-contributing-fields
                if(objectC3Type.getProperties().size() == 1){
                    GraphQLDirective keyDirective = GraphQLDirective.newDirective(FederationDirectives.key(fieldName))
                                                                    .argument(builder -> {
                                                                        builder.name("resolvable")
                                                                               .type(GraphQLTypeReference.typeRef(Scalars.GraphQLBoolean.getName()))
                                                                               .valueLiteral(new BooleanValue(false));
                                                                        return builder;
                                                                    }).build();
                    outputBuilder.withAppliedDirective(keyDirective.toAppliedDirective());
                }else{
                    outputBuilder.withAppliedDirective(FederationDirectives.key(fieldName).toAppliedDirective());
                }

            } else {

                fieldValue = conversionContext.convert(type);

                // If the field is an object, enum, or union type, we need to replace it with a reference to the object type
                // TODO: handle cases where the same object name is used across multiple different types in the same application
                //       To handle this we will need to keep track of all "Models" per application and check for conflicts
                //       Or this could be done by keeping the Conversion State around and converting all Structures for a application at once
                if (fieldValue.outputType() instanceof GraphQLObjectType objectType) {
                    String objectTypeName = objectType.getName();

                    conversionContext.state().getReferencedTypes().put(objectTypeName, objectType);
                    fieldValue = fieldValue.toBuilder().outputType(typeRef(objectTypeName)).build();
                }

                if (fieldValue.inputType() instanceof GraphQLInputObjectType inputObjectType) {
                    String inputTypeName = inputObjectType.getName();

                    conversionContext.state().getReferencedTypes().put(inputTypeName, inputObjectType);
                    fieldValue = fieldValue.toBuilder().inputType(typeRef(inputTypeName)).build();
                }

                // For union literals the DiscriminatorDecorator can be on the property, we capture that here.
                if(fieldValue.outputType() instanceof GraphQLUnionType unionType){

                    DiscriminatorDecorator discriminatorDecorator = property.findDecorator(DiscriminatorDecorator.class);
                    if(discriminatorDecorator != null && discriminatorDecorator.getPropertyName() != null){
                        // We don't check for existence since field level always takes precedence over the type level
                        conversionContext.state()
                                         .getUnionTypes()
                                         .put(unionType.getName(),
                                              Pair.of(unionType,
                                                      new DiscriminatorTypeResolver(discriminatorDecorator.getPropertyName())));
                    }
                }

                if (isNotNull(property)) {
                    GqlTypeHolder.GqlTypeHolderBuilder builder
                            = fieldValue.toBuilder()
                                        .outputType(nonNull(fieldValue.outputType()));
                    if (fieldValue.inputType() != null) {
                        builder.inputType(nonNull(fieldValue.inputType()));
                    }
                    fieldValue = builder.build();
                }
            }

            PolicyDecorator policyDecorator1 = property.findDecorator(PolicyDecorator.class);
            if(policyDecorator1 != null){

                outputBuilder.field(newFieldDefinition()
                                            .name(fieldName)
                                            .type(fieldValue.outputType())
                                            .withDirective(GqlUtils.policy(policyDecorator1.getPolicies())));
            }else{

                outputBuilder.field(newFieldDefinition()
                                            .name(fieldName)
                                            .type(fieldValue.outputType()));
            }

            // input type can be null in some cases such as a Union type.
            // This can create a paradigm mismatch between OpenApi and GraphQL, but we cannot do anything about it.
            // For now, we will not create an input type for these cases.
            if (fieldValue.inputType() != null) {
                if (isTypeRequiredForInput(property)) {
                    inputBuilder.field(newInputObjectField()
                                               .name(fieldName)
                                               .type(fieldValue.inputType()));
                }
            } else {
                nullInputTypeFound = true;
            }

            conversionContext.state().endProcessingField();
        }

        return new GqlTypeHolder(!nullInputTypeFound ? inputBuilder.build() : null, outputBuilder.build());
    }

    @Override
    public boolean supports(C3Type c3Type) {
        return c3Type instanceof ObjectC3Type;
    }

    private boolean isNotNull(PropertyDefinition propertyDefinition) {
        return propertyDefinition.containsDecorator(NotNullC3Decorator.class);
    }

    private boolean isTypeRequiredForInput(PropertyDefinition propertyDefinition) {
        // If the property is read only, we don't need to create an input type for it
        return !propertyDefinition.containsDecorator(ReadOnlyDecorator.class);
    }
}
