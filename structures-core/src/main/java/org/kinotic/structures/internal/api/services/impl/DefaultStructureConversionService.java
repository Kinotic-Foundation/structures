package org.kinotic.structures.internal.api.services.impl;

import co.elastic.clients.elasticsearch._types.mapping.ObjectProperty;
import co.elastic.clients.elasticsearch._types.mapping.Property;
import io.opentelemetry.instrumentation.annotations.WithSpan;
import io.swagger.v3.oas.models.media.Schema;
import lombok.RequiredArgsConstructor;
import org.kinotic.continuum.idl.api.converter.IdlConverter;
import org.kinotic.continuum.idl.api.converter.IdlConverterFactory;
import org.kinotic.continuum.idl.api.schema.decorators.C3Decorator;
import org.kinotic.structures.api.config.StructuresProperties;
import org.kinotic.structures.api.domain.Structure;
import org.kinotic.structures.api.domain.idl.decorators.*;
import org.kinotic.structures.internal.api.services.ElasticConversionResult;
import org.kinotic.structures.internal.api.services.StructureConversionService;
import org.kinotic.structures.internal.idl.converters.common.DecoratedProperty;
import org.kinotic.structures.internal.idl.converters.elastic.ElasticConversionState;
import org.kinotic.structures.internal.idl.converters.elastic.ElasticConverterStrategy;
import org.kinotic.structures.internal.idl.converters.graphql.GqlConversionState;
import org.kinotic.structures.internal.idl.converters.graphql.GqlConverterStrategy;
import org.kinotic.structures.internal.idl.converters.graphql.GqlTypeHolder;
import org.kinotic.structures.internal.idl.converters.openapi.OpenApiConversionState;
import org.kinotic.structures.internal.idl.converters.openapi.OpenApiConverterStrategy;
import org.springframework.stereotype.Component;

/**
 * Created by NavÃ­d Mitchell ðŸ¤ªon 5/11/23.
 */
@Component
@RequiredArgsConstructor
public class DefaultStructureConversionService implements StructureConversionService {

    private final IdlConverterFactory idlConverterFactory;
    private final StructuresProperties structuresProperties;

    @WithSpan
    @Override
    public ElasticConversionResult convertToElasticMapping(Structure structure) {
        ObjectProperty objectProperty;

        IdlConverter<Property, ElasticConversionState> converter = idlConverterFactory
                .createConverter(new ElasticConverterStrategy(structuresProperties));

        ElasticConversionState state = converter.getConversionContext().state();

        Property esProperty = converter.convert(structure.getEntityDefinition());

        if(esProperty.isObject()){
            objectProperty = esProperty.object();
        }else{
            throw new IllegalStateException("EntityDefinition must be an object");
        }

        return validateEntityDefinition(state, objectProperty);
    }

    private static ElasticConversionResult validateEntityDefinition(ElasticConversionState state, ObjectProperty objectProperty) {
        boolean idFieldFound = false;
        String versionFieldName = null;
        String tenantIdFieldName = null;

        for(DecoratedProperty prop : state.getDecoratedProperties()){
            if(prop.getDecorators() != null){

                for(C3Decorator decorator: prop.getDecorators()){
                    if(decorator instanceof IdDecorator
                            || decorator instanceof AutoGeneratedIdDecorator){

                        if(idFieldFound){
                            throw new IllegalArgumentException("Only one Id field can be defined for the EntityDefinition");
                        }

                        if(prop.getJsonPath().contains(".")){
                            throw new IllegalArgumentException("Id field cannot be nested");
                        }

                        idFieldFound = true;

                    } else if (decorator instanceof VersionDecorator) {

                        if(versionFieldName != null){
                            throw new IllegalArgumentException("Only one Version field can be defined for the EntityDefinition");
                        }

                        if(prop.getJsonPath().contains(".")){
                            throw new IllegalArgumentException("Version field cannot be nested");
                        }

                        versionFieldName = prop.getJsonPath();
                    } else if (decorator instanceof TenantIdDecorator) {

                        if(state.getMultiTenancyType() != MultiTenancyType.SHARED){
                            throw new IllegalArgumentException("The TenantId field can only be defined if the Entity has MultiTenancyType.SHARED set");
                        }

                        if(tenantIdFieldName != null){
                            throw new IllegalArgumentException("Only one TenantId field can be defined for the EntityDefinition");
                        }

                        if(prop.getJsonPath().contains(".")){
                            throw new IllegalArgumentException("TenantId field cannot be nested");
                        }
                        tenantIdFieldName = prop.getJsonPath();
                    }
                }
            }
        }

        if(!idFieldFound){
            throw new IllegalArgumentException("An Id field must be defined for the EntityDefinition");
        }

        return new ElasticConversionResult(state.getDecoratedProperties(),
                                           state.getMultiTenancyType(),
                                           objectProperty,
                                           versionFieldName,
                                           tenantIdFieldName);
    }

    @Override
    public IdlConverter<GqlTypeHolder, GqlConversionState> createGqlConverter() {
        return idlConverterFactory.createConverter(new GqlConverterStrategy(structuresProperties));
    }

    @Override
    public IdlConverter<Schema<?>, OpenApiConversionState> createOpenApiConverter(){
        return idlConverterFactory.createConverter(new OpenApiConverterStrategy(structuresProperties));
    }

}
