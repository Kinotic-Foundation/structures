package org.kinotic.structures.internal.api.hooks.impl;

import io.opentelemetry.instrumentation.annotations.WithSpan;
import org.apache.commons.lang3.tuple.Pair;
import org.kinotic.continuum.idl.api.schema.decorators.C3Decorator;
import org.kinotic.structures.api.config.StructuresProperties;
import org.kinotic.structures.api.domain.idl.decorators.AutoGeneratedIdDecorator;
import org.kinotic.structures.api.domain.idl.decorators.IdDecorator;
import org.kinotic.structures.api.domain.EntityContext;
import org.kinotic.structures.api.domain.Structure;
import org.kinotic.structures.api.domain.idl.decorators.MultiTenancyType;
import org.kinotic.structures.api.domain.idl.decorators.VersionDecorator;
import org.kinotic.structures.internal.api.hooks.DecoratorLogic;
import org.kinotic.structures.internal.api.hooks.UpsertFieldPreProcessor;
import org.kinotic.structures.internal.api.hooks.UpsertPreProcessor;
import org.kinotic.structures.internal.api.services.EntityHolder;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Created by NavÃ­d Mitchell ðŸ¤ª on 6/7/23.
 */
public class MapUpsertPreProcessor implements UpsertPreProcessor<Map<Object, Object>, List<Map<Object, Object>>, Map<Object, Object>> {

    private final Structure structure;
    private final StructuresProperties structuresProperties;
    private Pair<String, DecoratorLogic> idFieldPreProcessor = null;
    private String versionFieldName = null;

    public MapUpsertPreProcessor(Structure structure,
                                 StructuresProperties structuresProperties,
                                 Map<String, DecoratorLogic> fieldPreProcessors) {
        this.structure = structure;
        this.structuresProperties = structuresProperties;

        // this is a temporary solution since we only have an id and version field preprocessor now.
        for(Map.Entry<String, DecoratorLogic> entry : fieldPreProcessors.entrySet()) {
            C3Decorator decorator = entry.getValue().getDecorator();
            if(decorator instanceof IdDecorator
                    || decorator instanceof AutoGeneratedIdDecorator) {

                idFieldPreProcessor = Pair.of(entry.getKey(), entry.getValue());

            }else if(decorator instanceof VersionDecorator) {

                versionFieldName = entry.getKey();
            }
        }
    }

    @WithSpan
    @Override
    public CompletableFuture<EntityHolder<Map<Object, Object>>> process(Map<Object, Object> entity,
                                                                        EntityContext context) {
        try {
            return CompletableFuture.completedFuture(preProcessData(entity, context));
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    @WithSpan
    @Override
    public CompletableFuture<List<EntityHolder<Map<Object, Object>>>> processArray(List<Map<Object, Object>> entities,
                                                                                   EntityContext context) {
        try {
            List<EntityHolder<Map<Object, Object>>> entityHolders = new ArrayList<>();
            for(Map<Object, Object> entity : entities) {
                entityHolders.add(preProcessData(entity, context));
            }
            return CompletableFuture.completedFuture(entityHolders);
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private EntityHolder<Map<Object, Object>> preProcessData(Map<Object, Object> entity, EntityContext context) {
        String idFieldName = idFieldPreProcessor.getLeft();
        Object idFieldValue = entity.get(idFieldName);
        DecoratorLogic decoratorLogic = idFieldPreProcessor.getRight();
        C3Decorator decorator = decoratorLogic.getDecorator();
        UpsertFieldPreProcessor<C3Decorator, Object, Object> preProcessor = decoratorLogic.getProcessor();

        // we know this is the IdDecorator, so we can cast it
        String id = (String) preProcessor.process(structure, idFieldName, decorator, idFieldValue, context);

        // make sure the id is not null before appending to it
        if(id == null || id.isBlank()){
            throw new IllegalArgumentException("Id field cannot be null or blank");
        }

        // entity data gets id without tenant
        entity.put(idFieldName, id);

        // now verify the tenant id is set properly
        if(structure.getMultiTenancyType() == MultiTenancyType.SHARED){
            String existingTenantId = (String) entity.get(structuresProperties.getTenantIdFieldName());

            if(existingTenantId != null && !existingTenantId.equals(context.getParticipant().getTenantId())){
                throw new IllegalArgumentException("Tenant Id invalid for logged in participant");

            }else if(existingTenantId == null){
                entity.put(structuresProperties.getTenantIdFieldName(), context.getParticipant().getTenantId());
            }
        }

        // now extract version field if expected
        String version = null;
        if(structure.isOptimisticLockingEnabled()) {
            if(entity.containsKey(versionFieldName)) {
                version = (String) entity.get(versionFieldName);
                entity.remove(versionFieldName);
            }else{
                throw new IllegalArgumentException("No version field found in Entity");
            }
        }

        return new EntityHolder<>(entity,
                                  id,
                                  structure.getMultiTenancyType(),
                                  context.getParticipant().getTenantId(),
                                  version
        );
    }
}
