package org.kinotic.structures.internal.api.hooks.impl;

import io.opentelemetry.instrumentation.annotations.WithSpan;
import org.apache.commons.lang3.tuple.Pair;
import org.kinotic.continuum.idl.api.schema.decorators.C3Decorator;
import org.kinotic.structures.api.config.StructuresProperties;
import org.kinotic.structures.api.domain.idl.decorators.AutoGeneratedIdDecorator;
import org.kinotic.structures.api.domain.idl.decorators.IdDecorator;
import org.kinotic.structures.api.domain.EntityContext;
import org.kinotic.structures.api.domain.Structure;
import org.kinotic.structures.api.domain.idl.decorators.MultiTenancyType;
import org.kinotic.structures.api.domain.idl.decorators.VersionDecorator;
import org.kinotic.structures.internal.api.hooks.DecoratorLogic;
import org.kinotic.structures.internal.api.hooks.UpsertFieldPreProcessor;
import org.kinotic.structures.internal.api.hooks.UpsertPreProcessor;
import org.kinotic.structures.internal.api.services.EntityHolder;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Created by NavÃ­d Mitchell ðŸ¤ª on 6/7/23.
 */
public class MapUpsertPreProcessor implements UpsertPreProcessor<Map<Object, Object>, List<Map<Object, Object>>, Map<Object, Object>> {

    private final Structure structure;
    private final StructuresProperties structuresProperties;
    private Pair<String, DecoratorLogic> idFieldPreProcessor = null;
    private String versionFieldName = null;

    public MapUpsertPreProcessor(Structure structure,
                                 StructuresProperties structuresProperties,
                                 Map<String, DecoratorLogic> fieldPreProcessors) {
        this.structure = structure;
        this.structuresProperties = structuresProperties;

        // this is a temporary solution since we only have an id and version field preprocessor now.
        for(Map.Entry<String, DecoratorLogic> entry : fieldPreProcessors.entrySet()) {
            C3Decorator decorator = entry.getValue().getDecorator();
            if(decorator instanceof IdDecorator
                    || decorator instanceof AutoGeneratedIdDecorator) {

                idFieldPreProcessor = Pair.of(entry.getKey(), entry.getValue());

            }else if(decorator instanceof VersionDecorator) {

                versionFieldName = entry.getKey();
            }
        }
    }

    @WithSpan
    @Override
    public CompletableFuture<EntityHolder<Map<Object, Object>>> process(Map<Object, Object> entity,
                                                                        EntityContext context) {
        try {
            // We always blow away tenant selection on save/update since the only tenants that mater are the ones in the data
            // This is a sanity check, in case somehow it was already provided. We want to make sure auth services see the correct list.
            if(structure.isMultiTenantSelectionEnabled()){
                context.setTenantSelection(new ArrayList<>());
            }

            return CompletableFuture.completedFuture(preProcessData(entity, context));

        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    @WithSpan
    @Override
    public CompletableFuture<List<EntityHolder<Map<Object, Object>>>> processArray(List<Map<Object, Object>> entities,
                                                                                   EntityContext context) {
        try {
            // We always blow away tenant selection on save/update since the only tenants that mater are the ones in the data
            // This is a sanity check, in case somehow it was already provided. We want to make sure auth services see the correct list.
            if(structure.isMultiTenantSelectionEnabled()){
                context.setTenantSelection(new ArrayList<>());
            }

            List<EntityHolder<Map<Object, Object>>> entityHolders = new ArrayList<>();
            for(Map<Object, Object> entity : entities) {
                entityHolders.add(preProcessData(entity, context));
            }
            return CompletableFuture.completedFuture(entityHolders);
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private EntityHolder<Map<Object, Object>> preProcessData(Map<Object, Object> entity, EntityContext context) {
        String tenantId;
        String idFieldName = idFieldPreProcessor.getLeft();
        Object idFieldValue = entity.get(idFieldName);
        DecoratorLogic decoratorLogic = idFieldPreProcessor.getRight();
        C3Decorator decorator = decoratorLogic.getDecorator();
        UpsertFieldPreProcessor<C3Decorator, Object, Object> preProcessor = decoratorLogic.getProcessor();

        // we know this is the IdDecorator, so we can cast it
        String id = (String) preProcessor.process(structure, idFieldName, decorator, idFieldValue, context);

        // make sure the id is not null before appending to it
        if(id == null || id.isBlank()){
            throw new IllegalArgumentException("Could not find id for Entity");
        }

        // we just always put the id back into the entity to simplify the logic
        entity.put(idFieldName, id);

        // now verify the tenant id is set properly
        if(structure.getMultiTenancyType() == MultiTenancyType.SHARED){

            if(structure.isMultiTenantSelectionEnabled()){

                tenantId = (String) entity.get(structure.getTenantIdFieldName());
                if(tenantId == null){
                    throw new IllegalArgumentException("Could not find TenantId for Entity");
                }

                context.getTenantSelection().add(tenantId);

            } else {

                tenantId = (String) entity.get(structuresProperties.getTenantIdFieldName());

                if (tenantId != null && !tenantId.equals(context.getParticipant().getTenantId())) {
                    throw new IllegalArgumentException("Tenant Id invalid for logged in participant");

                } else if (tenantId == null) {
                    tenantId = context.getParticipant().getTenantId();
                    entity.put(structuresProperties.getTenantIdFieldName(), tenantId);
                }
            }
        }else {
            tenantId = null;
        }

        // now extract version field if expected
        String version = null;
        if(structure.isOptimisticLockingEnabled()) {
            if(entity.containsKey(versionFieldName)) {
                version = (String) entity.get(versionFieldName);
                entity.remove(versionFieldName);
            }
        }

        return new EntityHolder<>(entity,
                                  id,
                                  structure.getMultiTenancyType(),
                                  tenantId,
                                  version
        );
    }
}
