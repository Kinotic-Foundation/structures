package org.kinotic.structures.internal.api.hooks.impl;

import io.opentelemetry.instrumentation.annotations.WithSpan;
import org.apache.commons.lang3.tuple.Pair;
import org.kinotic.continuum.idl.api.schema.decorators.C3Decorator;
import org.kinotic.structures.api.config.StructuresProperties;
import org.kinotic.structures.api.domain.idl.decorators.AutoGeneratedIdDecorator;
import org.kinotic.structures.api.domain.idl.decorators.IdDecorator;
import org.kinotic.structures.api.domain.EntityContext;
import org.kinotic.structures.api.domain.Structure;
import org.kinotic.structures.api.domain.idl.decorators.MultiTenancyType;
import org.kinotic.structures.internal.api.hooks.DecoratorLogic;
import org.kinotic.structures.internal.api.hooks.UpsertFieldPreProcessor;
import org.kinotic.structures.internal.api.hooks.UpsertPreProcessor;
import org.kinotic.structures.internal.api.services.EntityHolder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Created by NavÃ­d Mitchell ðŸ¤ª on 6/7/23.
 */
public class MapUpsertPreProcessor implements UpsertPreProcessor<Map<Object, Object>, List<Map<Object, Object>>> {

    private static final Logger log = LoggerFactory.getLogger(MapUpsertPreProcessor.class);
    private final Structure structure;
    private final StructuresProperties structuresProperties;
    private Pair<String, DecoratorLogic> idFieldPreProcessor = null;

    public MapUpsertPreProcessor(Structure structure,
                                 StructuresProperties structuresProperties,
                                 Map<String, DecoratorLogic> fieldPreProcessors) {
        this.structure = structure;
        this.structuresProperties = structuresProperties;

        // this is a temporary solution since we only have an id field preprocessor now.
        for(Map.Entry<String, DecoratorLogic> entry : fieldPreProcessors.entrySet()) {
            C3Decorator decorator = entry.getValue().getDecorator();
            if(decorator instanceof IdDecorator
                || decorator instanceof AutoGeneratedIdDecorator) {
                idFieldPreProcessor = Pair.of(entry.getKey(), entry.getValue());
                break;
            }
        }
    }

    @WithSpan
    @Override
    public CompletableFuture<EntityHolder> process(Map<Object, Object> entity,
                                                   EntityContext context) {
        try {
            return CompletableFuture.completedFuture(preProcessData(entity, context));
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    @WithSpan
    @Override
    public CompletableFuture<List<EntityHolder>> processArray(List<Map<Object, Object>> entities,
                                                              EntityContext context) {
        try {
            List<EntityHolder> entityHolders = new ArrayList<>();
            for(Map<Object, Object> entity : entities) {
                entityHolders.add(preProcessData(entity, context));
            }
            return CompletableFuture.completedFuture(entityHolders);
        } catch (Exception e) {
            return CompletableFuture.failedFuture(e);
        }
    }

    private EntityHolder preProcessData(Map<Object, Object> entity, EntityContext context) {
        String fieldName = idFieldPreProcessor.getLeft();
        Object fieldValue = entity.get(fieldName);
        DecoratorLogic decoratorLogic = idFieldPreProcessor.getRight();
        C3Decorator decorator = decoratorLogic.getDecorator();
        UpsertFieldPreProcessor<C3Decorator, Object, Object> preProcessor = decoratorLogic.getProcessor();

        // we know this is the IdDecorator, so we can cast it
        String id = (String) preProcessor.process(structure, fieldName, decorator, fieldValue, context);

        // make sure the id is not null before appending to it
        if(id == null || id.isBlank()){
            throw new IllegalArgumentException("Id field cannot be null or blank");
        }

        // entity data gets id without tenant
        entity.put(fieldName, id);

        // now verify the tenant id is set properly
        if(structure.getMultiTenancyType() == MultiTenancyType.SHARED){
            String existingTenantId = (String) entity.get(structuresProperties.getTenantIdFieldName());

            if(existingTenantId != null && !existingTenantId.equals(context.getParticipant().getTenantId())){
                throw new IllegalArgumentException("Tenant Id invalid for logged in participant");

            }else if(existingTenantId == null){
                entity.put(structuresProperties.getTenantIdFieldName(), context.getParticipant().getTenantId());
            }
        }

        return new EntityHolder(entity,
                                id,
                                structure.getMultiTenancyType(),
                                context.getParticipant().getTenantId()
        );
    }
}
