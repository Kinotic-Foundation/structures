# Decorators Reference

This reference guide covers all available decorators in the Structures framework.

## Entity Decorators

### @Entity
Marks a class as a Structures entity. Required for all entity classes.

```typescript
@Entity(MultiTenancyType.SHARED)
export class Person {
    // ...
}
```

**Parameters:**
- `multiTenancyType`: `MultiTenancyType` - Specifies how the entity handles multi-tenancy
  - `MultiTenancyType.NONE`: No multi-tenancy support
  - `MultiTenancyType.SHARED`: Shared multi-tenancy
  - `MultiTenancyType.ISOLATED`: Isolated multi-tenancy

### @EntityServiceDecorators
Configures decorators to be applied to the EntityService.

```typescript
@EntityServiceDecorators({
    allCreate: [
        $Policy([['data:create']]),
        $Role(['admin'])
    ]
})
@Entity(MultiTenancyType.SHARED)
export class Person {
    // ...
}
```

## ID Decorators

### @AutoGeneratedId
Marks a property as an auto-generated ID. The server will automatically generate IDs for new entities.

```typescript
@AutoGeneratedId
public id: string | null = null
```

### @Id
Marks a property as the ID field. You must supply IDs when creating entities.

```typescript
@Id
public id: string = ''
```

## Field Decorators

### @Precision
Specifies the precision type for numeric fields.

```typescript
@Precision(PrecisionType.SHORT)
public age?: number
```

**Parameters:**
- `precisionType`: `PrecisionType`
  - `PrecisionType.INT`: Integer precision
  - `PrecisionType.SHORT`: Short precision
  - `PrecisionType.LONG`: Long precision
  - `PrecisionType.FLOAT`: Float precision
  - `PrecisionType.DOUBLE`: Double precision

### @NotIndexed
Marks a field to be excluded from Elasticsearch indexing.

```typescript
@NotIndexed
public notes?: string
```

### @Text
Marks a field for full-text search indexing.

```typescript
@Text
public description: string = ''
```

### @NotNull
Marks a field as required (non-nullable).

```typescript
@NotNull
public name: string = ''
```

### @Flattened
Marks a field to be flattened in Elasticsearch.

```typescript
@Flattened
public metadata: Record<string, any> = {}
```

### @Nested
Marks a field as a nested object in Elasticsearch.
If you need to index arrays of objects and to maintain the independence of each object in the array, use the nested data type

```typescript
@Nested
public address: Address = new Address()
```

## Relationship Decorators

### @Discriminator
Specifies a property to use as a discriminator for union types. This is essential when working with polymorphic relationships where an entity can be one of several types. The decorator automatically uses the property name it's applied to.

```typescript
@Discriminator
public type: string = ''  // The property name 'type' will be used as the discriminator
```

**Example with Union Types:**
```typescript
@Entity(MultiTenancyType.SHARED)
export class Pet {
    @AutoGeneratedId
    public id: string | null = null
    
    @Discriminator
    public type: string = ''  // Will be used as discriminator for Dog, Cat, etc.
}

@Entity(MultiTenancyType.SHARED)
export class Dog extends Pet {
    public breed: string = ''
}

@Entity(MultiTenancyType.SHARED)
export class Cat extends Pet {
    public lives: number = 9
}
```

## Policy Decorators

### @Policy
Defines access policies for entities, methods, or properties.

```typescript
@Policy([['data:read']])
@Entity(MultiTenancyType.SHARED)
export class Person {
    // ...
}
```

**Parameters:**
- `policies`: `string[][]` - Array of policy rules

### @Role
Defines role-based access control.

```typescript
@Role(['admin'])
public sensitiveMethod() {
    // ...
}
```

**Parameters:**
- `roles`: `string[]` - Array of role names

## Query Decorators

### @Query
Defines a custom query method. The workflow for adding custom queries is:

1. The CLI first generates the base Entity Service
2. You can then add your own methods with the `@Query` decorator and your custom query
3. Run `structures gen` to complete the implementation
4. Your new method will be available to call and will execute the query

```typescript
@Query('SELECT * FROM Person WHERE age > :age')
public findByAge(age: number): Promise<Person[]> {
    // Implementation is generated by the CLI
}
```

**Parameters:**
- `statements`: `string` - The query statement

**Example Workflow:**
```typescript
// 1. CLI generates the base service
// structures sync

// 2. Add your custom query method to the service
export class PersonEntityService extends BasePersonEntityService {
    @Query('SELECT * FROM Person WHERE age > :age')
    public findByAge(age: number): Promise<Person[]> {
        // Implementation will be generated
    }
}

// 3. Run structures gen to complete the implementation
// structures gen

// 4. Now you can use your custom query
const service = new PersonEntityService()
const adults = await service.findByAge(18)
```

## Multi-tenancy Decorators

### @TenantId
Marks a field as the tenant ID for multi-tenant entities. Adding this decorator enables "Admin" services for the Structure, which allow users to access data across different tenants. This is particularly useful for administrative operations that need to work with data from multiple tenants.

```typescript
@TenantId
public tenantId: string = ''
```

**Example with Admin Services:**
```typescript
// The Structures CLI automatically generates these service classes
// You don't need to define them manually

// Using the auto-generated services
const regularService = new PersonEntityService()
const adminService = new PersonWithTenantAdminEntityService()

// Regular service - only accesses current tenant
const users = await regularService.findAll()

// Admin service - requires tenant selection
const allUsers = await adminService.findAll(['*'])  // Access all tenants
const specificTenantUsers = await adminService.findAll(['tenant-123'])  // Access specific tenant
const multipleTenantUsers = await adminService.findAll(['tenant-123', 'tenant-456'])  // Access multiple tenants
```

**Important Notes:**
- Admin services should be used with caution as they bypass normal tenant isolation
- Access to admin services should be restricted to users with appropriate permissions
- When using admin services, you must specify a tenant selection as an array of strings:
  - `['*']` to access all tenants
  - `['tenant-id']` to access a specific tenant
  - `['tenant-id-1', 'tenant-id-2']` to access multiple specific tenants

## Version Control Decorators

### @Version
Enables optimistic locking support for entities. When an entity is updated, the version field is automatically incremented. If another process has modified the entity in the meantime (resulting in a different version), the update will fail, preventing concurrent modifications.

::: warning Version Field Type
The version field must be declared as `string | null`. Using any other type (like `number`) will cause type errors.
:::

```typescript
@Version
public version: string | null = null
```

**Example with Optimistic Locking:**
```typescript
@Entity(MultiTenancyType.SHARED)
export class Order {
    @AutoGeneratedId
    public id: string | null = null
    
    @Version
    public version: string | null = null
    
    public status: string = ''
}

// When updating an order:
const order = await orderService.findById('123')
order.status = 'SHIPPED'
try {
    await orderService.update(order)  // Will fail if order was modified by another process
} catch (error) {
    // Handle optimistic locking failure
}
```

## Time Reference Decorators

### @TimeReference
Marks a field as the time reference for data streams. This is essential for time-series data and stream processing, as it provides the temporal context for the data points.

```typescript
@TimeReference
public timestamp: Date = new Date()
```

**Example with Data Streams:**
```typescript
@Entity(MultiTenancyType.SHARED)
export class SensorReading {
    @AutoGeneratedId
    public id: string | null = null
    
    @TimeReference
    public timestamp: Date = new Date()
    
    public sensorId: string = ''
    public value: number = 0
}
```

## Examples

### Basic Entity
```typescript
@Entity(MultiTenancyType.SHARED)
export class Person {
    @AutoGeneratedId
    public id: string | null = null
    
    @NotNull
    public firstName: string = ''
    
    @NotNull
    public lastName: string = ''
    
    @Precision(PrecisionType.SHORT)
    public age?: number
    
    @NotIndexed
    public notes?: string
}
```

### Entity with Access Control
```typescript
@EntityServiceDecorators({
    allCreate: [
        $Policy([['order:create']]),
        $Role(['admin', 'sales'])
    ]
})
@Entity(MultiTenancyType.ISOLATED)
export class Order {
    @AutoGeneratedId
    public id: string | null = null
    
    @TenantId
    public tenantId: string = ''
    
    @Policy([['order:read']])
    public orderNumber: string = ''
    
    @Policy([['order:write']])
    public status: string = ''
}