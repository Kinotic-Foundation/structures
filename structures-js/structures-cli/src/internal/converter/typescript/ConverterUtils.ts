import {
    C3Decorator,
    C3Type,
    DoubleC3Type,
    FloatC3Type,
    IntC3Type,
    LongC3Type,
    NotNullDecorator, ShortC3Type
} from '@kinotic/continuum-idl'
import {
    AutoGeneratedIdDecorator,
    EntityDecorator,
    FlattenedDecorator,
    IdDecorator,
    MultiTenancyType,
    NestedDecorator,
    TextDecorator,
    DiscriminatorDecorator,
    QueryDecorator,
    EntityServiceDecoratorsDecorator,
    EntityServiceDecoratorsConfig,
    EntityType,
    PolicyDecorator,
    RoleDecorator,
    VersionDecorator,
    TenantIdDecorator,
    NotIndexedDecorator,
    EsIndexConfigurationData,
    EsIndexConfigurationDecorator,
    TimeReferenceDecorator
} from '@kinotic/structures-api'
import {Decorator, SyntaxKind, ObjectLiteralExpression, CallExpression} from 'ts-morph'

export function tsDecoratorToC3Decorator(decorator: Decorator): C3Decorator | null {
    let ret: C3Decorator | null = null

    if (decorator.getName() === 'AutoGeneratedId') {
        ret = new AutoGeneratedIdDecorator()
    } else if (decorator.getName() === 'Discriminator') {
        const discriminatorDecorator = new DiscriminatorDecorator()
        if (decorator.getArguments().length == 1) {
            const argument = decorator.getArguments()[0]
            if (argument?.getType()?.getLiteralValue()) {
                discriminatorDecorator.propertyName = argument.getType().getLiteralValue() as string
            } else {
                throw new Error('propertyName must be a string literal')
            }
        }else{
            throw new Error('propertyName must be set on Discriminator Decorator')
        }
        ret = discriminatorDecorator
    } else if (decorator.getName() === 'Entity') {
        const entityDecorator = new EntityDecorator()
        if (decorator.getArguments().length > 0) {
            const argument = decorator.getArguments()[0]
            if (argument?.getText() == 'MultiTenancyType.SHARED') {
                entityDecorator.multiTenancyType = MultiTenancyType.SHARED
            } else if (argument?.getText() == 'MultiTenancyType.NONE') {
                entityDecorator.multiTenancyType = MultiTenancyType.NONE
            } else {
                throw new Error(`Unsupported MultiTenancyType ${argument?.getText()}`)
            }

            if(decorator.getArguments().length == 2){
                const entityTypeArg = decorator.getArguments()[1]
                if (entityTypeArg?.getText() == 'EntityType.TABLE') {
                    entityDecorator.entityType = EntityType.TABLE
                } else if (entityTypeArg?.getText() == 'EntityType.STREAM') {
                    entityDecorator.entityType = EntityType.STREAM
                } else {
                    throw new Error(`Unsupported EntityType ${entityTypeArg?.getText()}`)
                }
            }
        }
        ret = entityDecorator
    } else if (decorator.getName() === 'EntityServiceDecorators') {
        const argument = decorator.getArguments()[0]
        if (argument?.getKind() === SyntaxKind.ObjectLiteralExpression) {
            const obj = convertToObjectLiteral(argument as ObjectLiteralExpression)
            ret = {
                type  : 'EntityServiceDecorators',
                config: obj as EntityServiceDecoratorsConfig,
            } as EntityServiceDecoratorsDecorator
        } else {
            throw new Error('EntityServiceDecorators must have an object literal argument')
        }
    } else if (decorator.getName() === 'EsIndexConfiguration') {
        const argument = decorator.getArguments()[0]
        if (argument?.getKind() === SyntaxKind.ObjectLiteralExpression) {
            const obj = convertToObjectLiteral(argument as ObjectLiteralExpression)
            ret = {
                type  : 'EsIndexConfigurationDecorator',
                value: obj as EsIndexConfigurationData,
            } as EsIndexConfigurationDecorator
        } else {
            throw new Error('EsIndexConfiguration must have an object literal argument')
        }
    } else if (decorator.getName() === 'Flattened') {
        ret = new FlattenedDecorator()
    } else if (decorator.getName() === 'Id') {
        ret = new IdDecorator()
    } else if (decorator.getName() === 'Nested') {
        ret = new NestedDecorator()
    } else if (decorator.getName() === 'NotIndexed') {
        ret = new NotIndexedDecorator()
    } else if (decorator.getName() === 'NotNull') {
        ret = new NotNullDecorator()
    } else if (decorator.getName() === 'Policy') {
        const argument = decorator.getArguments()[0]
        if (argument?.getKind() === SyntaxKind.ArrayLiteralExpression) {
            const obj = parseExpressionToJs(argument)
            ret = {
                type: 'PolicyDecorator',
                policies: obj as string[][],
            } as PolicyDecorator
        } else {
            throw new Error('Policy must have an array literal argument')
        }
    } else if (decorator.getName() === 'Query') {
        if (decorator.getArguments().length == 1) {
            const argument = decorator.getArguments()[0]
            if (argument?.getType()?.getLiteralValue()) {
                ret = new QueryDecorator(argument.getType().getLiteralValue() as string)
            } else {
                throw new Error('statement must be set on Query Decorator')
            }
        }
    } else if (decorator.getName() === 'Role') {
        const argument = decorator.getArguments()[0]
        if (argument?.getKind() === SyntaxKind.ArrayLiteralExpression) {
            const obj = parseExpressionToJs(argument)
            ret = {
                type: 'RoleDecorator',
                roles: obj as string[],
            } as RoleDecorator
        } else {
            throw new Error('Role must have an array literal argument')
        }
    } else if (decorator.getName() === 'TenantId') {
        ret = new TenantIdDecorator()
    } else if (decorator.getName() === 'Text') {
        ret = new TextDecorator()
    } else if (decorator.getName() === 'TimeReference') {
        ret = new TimeReferenceDecorator()
    } else if (decorator.getName() === 'Version') {
        ret = new VersionDecorator()
    }

    return ret
}


export function convertPrecisionToC3Type(decorator: Decorator): C3Type {
    let ret: C3Type
    if(decorator.getName() === 'Precision'){
        if (decorator.getArguments().length == 1) {
            const argument = decorator.getArguments()[0]
            if (argument?.getText() == 'PrecisionType.DOUBLE') {
                ret = new DoubleC3Type()
            } else if (argument?.getText() == 'PrecisionType.FLOAT') {
                ret = new FloatC3Type()
            } else if (argument?.getText() == 'PrecisionType.INT') {
                ret = new IntC3Type()
            } else if (argument?.getText() == 'PrecisionType.LONG') {
                ret = new LongC3Type()
            } else if (argument?.getText() == 'PrecisionType.SHORT') {
                ret = new ShortC3Type()
            } else {
                throw new Error(`Unsupported PrecisionType ${argument?.getText()}`)
            }
        }else{
            ret = new IntC3Type()
        }
        return ret
    }else{
        throw new Error('Decorator is not Precision decorator')
    }
}

function parseExpressionToJs(expression: any): any {
    switch (expression.getKind()) {
        case SyntaxKind.AsExpression:
            // Directly handle the expression part of the AsExpression
            const asExpr = expression.asKindOrThrow(SyntaxKind.AsExpression)
            return parseExpressionToJs(asExpr.getExpression())
        case SyntaxKind.ObjectLiteralExpression:
            return convertToObjectLiteral(expression as ObjectLiteralExpression)
        case SyntaxKind.ArrayLiteralExpression:
            return expression.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)
                             .getElements()
                             .map((el: any) => parseExpressionToJs(el))
        case SyntaxKind.StringLiteral:
            return expression.asKindOrThrow(SyntaxKind.StringLiteral).getLiteralValue()
        case SyntaxKind.NumericLiteral:
            return parseFloat(expression.asKindOrThrow(SyntaxKind.NumericLiteral).getLiteralText())
        case SyntaxKind.TrueKeyword:
            return true
        case SyntaxKind.FalseKeyword:
            return false
        case SyntaxKind.CallExpression:
            const callExpr = expression.asKindOrThrow(SyntaxKind.CallExpression)
            if(callExpr.getText().startsWith('$')){ // Check if it is a supported internal function
                return convertCallExpressionToJs(callExpr)
            }else{
                throw new Error(`Unsupported call expression: ${callExpr.getText()}`)
            }
        default:
            throw new Error(`Unsupported expression kind: ${expression.getKindName()} text: ${expression.getText()}`)
    }
}

function convertCallExpressionToJs(expression: CallExpression): any {
    const text = expression.getText()
    if(text.startsWith('$Policy')){
        if(expression.getArguments().length === 1){
            const argument = expression.getArguments()[0]
            const obj = parseExpressionToJs(argument)
            // Validate the parsed object structure
            if (!Array.isArray(obj) || !obj.every(arr => Array.isArray(arr) && arr.every(item => typeof item === 'string'))) {
                throw new Error('Policy must contain an array of string arrays (string[][])')
            }
            return {
                type: 'PolicyDecorator',
                policies: obj as string[][], // Fixed type assertion
            } as PolicyDecorator
        }else {
            throw new Error('Policy must have an array literal argument')
        }
    }else if (text.startsWith('$Role')){
        if(expression.getArguments().length == 1){
            const argument = expression.getArguments()[0]
            const obj = parseExpressionToJs(argument)
            return {
                type: 'RoleDecorator',
                roles: obj as string[],
            } as RoleDecorator
        }else {
            throw new Error('Role must have an array literal argument')
        }
    }else{
        throw new Error(`Unsupported call expression: ${text}`)
    }
}

// Convert ObjectLiteralExpression to a JavaScript object
function convertToObjectLiteral(expression: ObjectLiteralExpression): any {
    const result: any = {}
    for(const prop of expression.getProperties()) {
        if (prop.getKind() === SyntaxKind.PropertyAssignment) {
            const assignment = prop.asKindOrThrow(SyntaxKind.PropertyAssignment)
            const key = assignment.getName()
            const initializer = assignment.getInitializer()
            if (initializer) {
                result[key] = parseExpressionToJs(initializer)
            }
        }
    }
    return result
}
