import {
    C3Decorator,
    C3Type,
    DoubleC3Type,
    FloatC3Type,
    IntC3Type,
    LongC3Type,
    NotNullDecorator, ShortC3Type
} from '@kinotic/continuum-idl'
import {
    AutoGeneratedIdDecorator,
    EntityDecorator,
    FlattenedDecorator,
    IdDecorator,
    MultiTenancyType, NestedDecorator,
    TextDecorator,
    DiscriminatorDecorator
} from '@kinotic/structures-api'
import {Decorator} from 'ts-morph'

export function tsDecoratorToC3Decorator(decorator: Decorator): C3Decorator{
    let ret: C3Decorator

    if(decorator.getName() === 'Entity'){
        const entityDecorator = new EntityDecorator()
        if (decorator.getArguments().length == 1) {
            const argument = decorator.getArguments()[0]
            if (argument?.getText() == 'MultiTenancyType.SHARED') {
                entityDecorator.multiTenancyType = MultiTenancyType.SHARED
            } else if (argument?.getText() == 'MultiTenancyType.NONE') {
                entityDecorator.multiTenancyType = MultiTenancyType.NONE
            } else {
                throw new Error(`Unsupported MultiTenancyType ${argument?.getText()}`)
            }
        }
        ret = entityDecorator
    }else if(decorator.getName() === 'Id') {
        ret = new IdDecorator()
    }else if(decorator.getName() === 'AutoGeneratedId') {
        ret = new AutoGeneratedIdDecorator()
    }else if(decorator.getName() === 'Flattened') {
        ret = new FlattenedDecorator()
    }else if(decorator.getName() === 'Nested') {
        ret = new NestedDecorator()
    }else if(decorator.getName() === 'Text') {
        ret = new TextDecorator()
    }else if(decorator.getName() === 'NotNull') {
        ret = new NotNullDecorator()
    }else if(decorator.getName() === 'Discriminator') {
        const discriminatorDecorator = new DiscriminatorDecorator()
        if (decorator.getArguments().length == 1) {
            const argument = decorator.getArguments()[0]
            if (argument?.getType()?.getLiteralValue()) {
                discriminatorDecorator.propertyName = argument.getType().getLiteralValue() as string
            } else {
                throw new Error('propertyName must be set on Discriminator Decorator}')
            }
        }
        ret = discriminatorDecorator
    }else{
        throw new Error(`Unsupported decorator ${decorator.getName()}`)
    }

    return ret
}

export function convertPrecisionToC3Type(decorator: Decorator): C3Type {
    let ret: C3Type
    if(decorator.getName() === 'Precision'){
        if (decorator.getArguments().length == 1) {
            const argument = decorator.getArguments()[0]
            if (argument?.getText() == 'PrecisionType.DOUBLE') {
                ret = new DoubleC3Type()
            } else if (argument?.getText() == 'PrecisionType.FLOAT') {
                ret = new FloatC3Type()
            } else if (argument?.getText() == 'PrecisionType.INT') {
                ret = new IntC3Type()
            } else if (argument?.getText() == 'PrecisionType.LONG') {
                ret = new LongC3Type()
            } else if (argument?.getText() == 'PrecisionType.SHORT') {
                ret = new ShortC3Type()
            } else {
                throw new Error(`Unsupported PrecisionType ${argument?.getText()}`)
            }
        }else{
            ret = new IntC3Type()
        }
        return ret
    }else{
        throw new Error('Decorator is not Precision decorator')
    }
}
