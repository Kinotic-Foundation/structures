var S = Object.defineProperty;
var m = (r, e, t) => e in r ? S(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var s = (r, e, t) => (m(r, typeof e != "symbol" ? e + "" : e, t), t);
import { C3Decorator as u } from "@kinotic/continuum-idl";
import { AbstractIterablePage as h, Continuum as o, CrudServiceProxy as v } from "@kinotic/continuum-client";
import "reflect-metadata";
class L {
  constructor(e, t, i, n) {
    s(this, "id");
    s(this, "namespace");
    s(this, "structure");
    s(this, "namedQueries");
    this.id = e, this.namespace = t, this.structure = i, this.namedQueries = n;
  }
}
class G {
  constructor(e, t, i) {
    s(this, "id");
    s(this, "description");
    s(this, "updated");
    this.id = e, this.description = t, this.updated = i;
  }
}
class q {
  // do not ever set, system managed
  constructor(e, t, i, n) {
    s(this, "id");
    s(this, "namespace");
    s(this, "name");
    s(this, "entityDefinition");
    s(this, "description");
    s(this, "created");
    // do not ever set, system managed
    s(this, "updated");
    // do not ever set, system managed
    s(this, "published");
    // do not ever set, system managed
    s(this, "publishedTimestamp");
    this.namespace = e, this.name = t, this.entityDefinition = i, this.description = n;
  }
}
class H extends u {
  constructor() {
    super(), this.type = "AutoGeneratedId";
  }
}
class V extends u {
  constructor() {
    super();
    s(this, "propertyName");
    this.type = "Discriminator";
  }
  withPropertyName(t) {
    return this.propertyName = t, this;
  }
}
var l = /* @__PURE__ */ ((r) => (r[r.NONE = 0] = "NONE", r[r.SHARED = 1] = "SHARED", r))(l || {});
class J extends u {
  constructor() {
    super();
    s(this, "multiTenancyType", l.NONE);
    this.type = "Entity";
  }
  withMultiTenancyType(t) {
    return this.multiTenancyType = t, this;
  }
}
class j extends u {
  constructor() {
    super(), this.type = "Flattened";
  }
}
class z extends u {
  constructor() {
    super(), this.type = "Id";
  }
}
class K extends u {
  constructor() {
    super(), this.type = "Nested";
  }
}
class W extends u {
  constructor(t) {
    super();
    s(this, "statements");
    this.type = "Query", this.statements = t;
  }
}
class X extends u {
  constructor() {
    super(), this.type = "Text";
  }
}
class I extends h {
  constructor(t, i, n, c) {
    super(i, n);
    s(this, "structureId");
    s(this, "entitiesService");
    this.entitiesService = t, this.structureId = c;
  }
  findNext(t) {
    return this.entitiesService.findAllSinglePage(this.structureId, t);
  }
}
class x extends h {
  constructor(t, i, n, c, a) {
    super(i, n);
    s(this, "searchText");
    s(this, "structureId");
    s(this, "entitiesService");
    this.entitiesService = t, this.searchText = c, this.structureId = a;
  }
  findNext(t) {
    return this.entitiesService.searchSinglePage(this.structureId, this.searchText, t);
  }
}
class p {
  constructor(e) {
    s(this, "serviceProxy");
    const t = "org.kinotic.structures.api.services.JsonEntitiesService";
    this.serviceProxy = (e == null ? void 0 : e.serviceProxy(t)) || o.serviceProxy(t);
  }
  bulkSave(e, t) {
    return this.serviceProxy.invoke("bulkSave", [e, t]);
  }
  bulkUpdate(e, t) {
    return this.serviceProxy.invoke("bulkUpdate", [e, t]);
  }
  count(e) {
    return this.serviceProxy.invoke("count", [e]);
  }
  countByQuery(e, t) {
    return this.serviceProxy.invoke("countByQuery", [e, t]);
  }
  deleteById(e, t) {
    return this.serviceProxy.invoke("deleteById", [e, t]);
  }
  deleteByQuery(e, t) {
    return this.serviceProxy.invoke("deleteByQuery", [e, t]);
  }
  async findAll(e, t) {
    const i = await this.findAllSinglePage(e, t);
    return new I(this, t, i, e);
  }
  async findAllSinglePage(e, t) {
    return this.serviceProxy.invoke("findAll", [e, t]);
  }
  findById(e, t) {
    return this.serviceProxy.invoke("findById", [e, t]);
  }
  findByIds(e, t) {
    return this.serviceProxy.invoke("findByIds", [e, t]);
  }
  namedQuery(e, t, i) {
    return this.serviceProxy.invoke("namedQuery", [e, t, i]);
  }
  save(e, t) {
    return this.serviceProxy.invoke("save", [e, t]);
  }
  async search(e, t, i) {
    const n = await this.searchSinglePage(e, t, i);
    return new x(this, i, n, t, e);
  }
  async searchSinglePage(e, t, i) {
    return this.serviceProxy.invoke("search", [e, t, i]);
  }
  update(e, t) {
    return this.serviceProxy.invoke("update", [e, t]);
  }
}
const N = new p();
class E extends h {
  constructor(t, i, n, c, a, d, f) {
    super(n, c);
    s(this, "pageableIndex");
    s(this, "parameters");
    s(this, "queryName");
    s(this, "structureId");
    s(this, "entitiesService");
    this.entitiesService = t, this.pageableIndex = i, this.parameters = a, this.queryName = d, this.structureId = f;
  }
  findNext(t) {
    return this.parameters[this.pageableIndex].value = t, this.entitiesService.namedQuery(this.structureId, this.queryName, this.parameters);
  }
}
class P {
  constructor(e, t, i) {
    s(this, "structureNamespace");
    s(this, "structureName");
    s(this, "structureId");
    s(this, "entitiesService");
    this.structureNamespace = e, this.structureName = t, this.structureId = (e + "." + t).toLowerCase(), this.entitiesService = i || N;
  }
  async bulkSave(e) {
    const t = await this.beforeBulkSaveOrUpdate(e);
    return this.entitiesService.bulkSave(this.structureId, t);
  }
  async bulkUpdate(e) {
    const t = await this.beforeBulkSaveOrUpdate(e);
    return this.entitiesService.bulkUpdate(this.structureId, t);
  }
  count() {
    return this.entitiesService.count(this.structureId);
  }
  countByQuery(e) {
    return this.entitiesService.countByQuery(this.structureId, e);
  }
  deleteById(e) {
    return this.entitiesService.deleteById(this.structureId, e);
  }
  deleteByQuery(e) {
    return this.entitiesService.deleteByQuery(this.structureId, e);
  }
  findAll(e) {
    return this.entitiesService.findAll(this.structureId, e);
  }
  findById(e) {
    return this.entitiesService.findById(this.structureId, e);
  }
  findByIds(e) {
    return this.entitiesService.findByIds(this.structureId, e);
  }
  namedQuery(e, t) {
    return this.entitiesService.namedQuery(this.structureId, e, t);
  }
  async namedQueryPage(e, t, i, n) {
    const c = await this.entitiesService.namedQuery(this.structureId, e, t);
    return new E(this.entitiesService, n, i, c, t, e, this.structureId);
  }
  async save(e) {
    const t = await this.beforeSaveOrUpdate(e);
    return this.entitiesService.save(this.structureId, t);
  }
  search(e, t) {
    return this.entitiesService.search(this.structureId, e, t);
  }
  async update(e) {
    const t = await this.beforeSaveOrUpdate(e);
    return this.entitiesService.update(this.structureId, t);
  }
  async beforeBulkSaveOrUpdate(e) {
    return Promise.resolve(e);
  }
  async beforeSaveOrUpdate(e) {
    return Promise.resolve(e);
  }
}
class g extends v {
  constructor() {
    super(o.serviceProxy("org.kinotic.structures.api.services.NamedQueriesService"));
  }
}
class k extends v {
  constructor() {
    super(o.serviceProxy("org.kinotic.structures.api.services.NamespaceService"));
  }
  createNamespaceIfNotExist(e, t) {
    return this.serviceProxy.invoke("createNamespaceIfNotExist", [e, t]);
  }
}
class b extends v {
  constructor() {
    super(o.serviceProxy("org.kinotic.structures.api.services.StructureService"));
  }
  findAllPublishedForNamespace(e, t) {
    return this.serviceProxy.invoke("findAllPublishedForNamespace", [e, t]);
  }
  countForNamespace(e) {
    return this.serviceProxy.invoke("countForNamespace", [e]);
  }
  publish(e) {
    return this.serviceProxy.invoke("publish", [e]);
  }
  unPublish(e) {
    return this.serviceProxy.invoke("unPublish", [e]);
  }
}
const Q = new k(), B = new b(), w = new p(), A = new g();
var y;
((r) => {
  function e() {
    return Q;
  }
  r.getNamespaceService = e;
  function t() {
    return B;
  }
  r.getStructureService = t;
  function i() {
    return w;
  }
  r.getEntitiesService = i;
  function n() {
    return A;
  }
  r.getNamedQueriesService = n;
  function c(a, d) {
    return new P(a, d);
  }
  r.createEntityService = c;
})(y || (y = {}));
var _ = /* @__PURE__ */ ((r) => (r[r.DOUBLE = 0] = "DOUBLE", r[r.FLOAT = 1] = "FLOAT", r[r.INT = 2] = "INT", r[r.LONG = 3] = "LONG", r[r.SHORT = 4] = "SHORT", r))(_ || {}), T = /* @__PURE__ */ ((r) => (r.Entity = "__structures-entity__", r.Id = "__structures-id__", r.AutoGeneratedId = "__structures-auto-generated-id__", r.Flattened = "__structures-flattened__", r.Nested = "__structures-nested__", r.Text = "__structures-text__", r.NotNull = "__structures-notnull__", r.Precision = "__structures-precision__", r.Discriminator = "__structures-discriminator__", r.Query = "__structures-query__", r))(T || {});
class O {
  constructor(e) {
    s(this, "multiTenancyType");
    this.multiTenancyType = e;
  }
}
function Y(r = l.NONE) {
  return function(e) {
    Reflect.defineMetadata("__structures-entity__", new O(r), e);
  };
}
function Z(r, e) {
  Reflect.defineMetadata("__structures-id__", {}, r, e);
}
function $(r, e) {
  Reflect.defineMetadata("__structures-auto-generated-id__", {}, r, e);
}
function ee(r, e) {
  Reflect.defineMetadata("__structures-flattened__", {}, r, e);
}
function te(r, e) {
  Reflect.defineMetadata("__structures-nested__", {}, r, e);
}
function re(r, e) {
  Reflect.defineMetadata("__structures-text__", {}, r, e);
}
function se(r, e) {
  Reflect.defineMetadata("__structures-notnull__", {}, r, e);
}
function ie(r) {
  return function(e, t, i) {
    return Reflect.defineMetadata("__structures-query__", r, e, t), i;
  };
}
class R {
  constructor(e) {
    s(this, "precisionType");
    this.precisionType = e;
  }
}
function ne(r = _.INT) {
  return function(e, t) {
    Reflect.defineMetadata("__structures-precision__", new R(r), e, t);
  };
}
class U {
  constructor(e) {
    s(this, "propertyName");
    this.propertyName = e;
  }
}
function ce(r) {
  return function(e, t) {
    Reflect.defineMetadata("__structures-discriminator__", new U(r), e, t);
  };
}
export {
  $ as AutoGeneratedId,
  H as AutoGeneratedIdDecorator,
  ce as Discriminator,
  U as DiscriminatorConfig,
  V as DiscriminatorDecorator,
  p as EntitiesService,
  N as EntitiesServiceSingleton,
  Y as Entity,
  O as EntityConfig,
  J as EntityDecorator,
  P as EntityService,
  ee as Flattened,
  j as FlattenedDecorator,
  Z as Id,
  z as IdDecorator,
  l as MultiTenancyType,
  L as NamedQueriesDefinition,
  g as NamedQueriesService,
  G as Namespace,
  k as NamespaceService,
  te as Nested,
  K as NestedDecorator,
  se as NotNull,
  ne as Precision,
  R as PrecisionConfig,
  ie as Query,
  W as QueryDecorator,
  q as Structure,
  b as StructureService,
  y as Structures,
  T as StructuresDecorator,
  re as Text,
  X as TextDecorator
};
//# sourceMappingURL=structures-api.js.map
