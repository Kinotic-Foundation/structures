import { EntityService, IEntitiesService } from '@kinotic/structures-api'
import { Product } from '../../../domain/ecommerce/Product.js'


/**
 * Base Service for interacting with Product entities
 * This class was generated by the Structures CLI. And will be overwritten if the CLI is run again.
 */
export class BaseProductEntityService extends EntityService<Product> {

  private readonly shouldValidate: boolean

  constructor(shouldValidate: boolean = true, entitiesService?: IEntitiesService) {
    super('ecommerce', 'Product', entitiesService)
    this.shouldValidate = shouldValidate
  }

  protected async beforeSaveOrUpdate(entity: Product): Promise<Product> {
    if (this.shouldValidate) {
      return this.validate(entity)
    } else {
      return entity
    }
  }

  protected async beforeBulkSaveOrUpdate(entities: Product[]): Promise<Product[]> {
    if (this.shouldValidate) {
      const validatedEntities: Product[] = []
      for (let entity of entities) {
        validatedEntities.push(this.validate(entity))
      }
      return validatedEntities
    } else {
      return entities
    }
  }

  validate(entity: Product): Product {
    let ret: any
    if (entity) {
      ret = (ret ? ret : {})
      ret.id = entity.id
      ret.name = entity.name
      ret.description = entity.description
      ret.sku = entity.sku
      ret.price = entity.price
      ret.salePrice = entity.salePrice
      ret.stockQuantity = entity.stockQuantity
      ret.brand = entity.brand
      ret.category = entity.category
      if (entity.tags) {
        ret.tags = []
        for (let entityTagsItem of entity.tags) {
          let retTagsValue: any
          retTagsValue = entityTagsItem
          ret.tags.push(retTagsValue)
        }
      }
      if (entity.attributes) {
        ret.attributes = []
        for (let entityAttributesItem of entity.attributes) {
          let retAttributesValue: any
          if (entityAttributesItem) {
            retAttributesValue = (retAttributesValue ? retAttributesValue : {})
            retAttributesValue.key = entityAttributesItem.key
            retAttributesValue.value = entityAttributesItem.value
          }
          ret.attributes.push(retAttributesValue)
        }
      }
      if (entity.images) {
        ret.images = []
        for (let entityImagesItem of entity.images) {
          let retImagesValue: any
          if (entityImagesItem) {
            retImagesValue = (retImagesValue ? retImagesValue : {})
            retImagesValue.url = entityImagesItem.url
            retImagesValue.type = entityImagesItem.type
            retImagesValue.altText = entityImagesItem.altText
            retImagesValue.width = entityImagesItem.width
            retImagesValue.height = entityImagesItem.height
            retImagesValue.size = entityImagesItem.size
            retImagesValue.format = entityImagesItem.format
            retImagesValue.isDefault = entityImagesItem.isDefault
            retImagesValue.sortOrder = entityImagesItem.sortOrder
            retImagesValue.variantId = entityImagesItem.variantId
          }
          ret.images.push(retImagesValue)
        }
      }
    }

    return ret
  }

}
