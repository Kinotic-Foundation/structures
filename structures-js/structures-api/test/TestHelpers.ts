import delay from 'delay'
// @ts-ignore for some reason intellij is complaining about this even though esModuleInterop is enabled
import path from 'node:path'
import * as compose from 'docker-compose'
import {Continuum, Direction, Order, Pageable} from '@kinotic/continuum-client'
import {
    ObjectC3Type,
    StringC3Type
} from '@kinotic/continuum-idl'
import {expect} from 'vitest'
import {IterablePage} from '@kinotic/continuum-client'
import {
    Structures,
    MultiTenancyType,
    EntityDecorator,
    Structure,
    AutoGeneratedIdDecorator,
    IEntityService
} from '../src'
import {Person} from './domain/Person.js'

export async function initContinuumClient(): Promise<void> {
    try {
        await Continuum.connect({
            host:'localhost',
            port:58503,
            connectHeaders:{login: 'admin', passcode: 'structures'}
        })

        console.log('Connected to continuum')
    } catch (e) {
        console.error(e)
        throw e
    }
}

export async function shutdownContinuumClient(): Promise<void> {
    try {
        await Continuum.disconnect()
    } catch (e) {
        console.error(e)
        throw e
    }
}

export function createPersonSchema(suffix: string): ObjectC3Type {
    const ret = new ObjectC3Type('Person' + suffix,
                                    'structures.api.tests')
    ret.addDecorator(new EntityDecorator().withMultiTenancyType(MultiTenancyType.SHARED))
    ret.addProperty('id', new StringC3Type(), [new AutoGeneratedIdDecorator()])
    ret.addProperty('firstName', new StringC3Type())
    ret.addProperty('lastName', new StringC3Type())
    // ret.addProperty('age', new IntC3Type())

    const address = new ObjectC3Type('Address',
                                     'structures.api.tests')
    address.addProperty('street', new StringC3Type())
    address.addProperty('city', new StringC3Type())
    address.addProperty('state', new StringC3Type())
    address.addProperty('zip', new StringC3Type())

    ret.addProperty('address', address)

    return ret
}

export async function createPersonStructureIfNotExist(suffix: string): Promise<Structure>{
    const structureId = 'structures.api.tests.person' + suffix
    let structure = await Structures.getStructureService().findById(structureId)
    if(structure == null){
        structure = await createPersonStructure(suffix)
    }
    return structure
}

export async function createPersonStructure(suffix: string): Promise<Structure>{
    const personStructure = new Structure('structures.api.tests',
        'Person' + suffix,
        createPersonSchema(suffix),
        'Tracks people that are going to mars')

    await Structures.getNamespaceService().createNamespaceIfNotExist('structures.api.tests', 'Sample Data Namespace')

    const savedStructure = await Structures.getStructureService().create(personStructure)

    await Structures.getStructureService().publish(savedStructure.id)

    return savedStructure
}

export async function deleteStructure(structureId: string): Promise<void>{
    await Structures.getStructureService().unPublish(structureId)
    await Structures.getStructureService().deleteById(structureId)
}

export function createTestPeople(numberToCreate: number): Person[] {
    const ret: Person[] = []
    for (let i = 0; i < numberToCreate; i++) {
        ret.push(createTestPerson(i))
    }
    return ret
}

export async function createTestPeopleAndVerify(entityService: IEntityService<Person>,
                                                numberToCreate: number,
                                                delayAfterUpdate: number): Promise<void> {
    // Create people
    const people: Person[] = createTestPeople(numberToCreate)
    await expect(entityService.bulkSave(people)).resolves.toBeNull()

    await delay(delayAfterUpdate)

    // Count the people
    await expect(entityService.count()).resolves.toBe(numberToCreate)
}

export async function findAndVerifyPeopleWithCursorPaging(entityService: IEntityService<Person>,
                                                   numberToExpect: number){
    let elementsFound = 0
    const pageable = Pageable.createWithCursor(null,
                                               10,
                                               { orders: [
                                                       new Order('firstName', Direction.ASC),
                                                       new Order('id', Direction.ASC)
                                                   ] })
    const firstPage: IterablePage<Person> = await entityService.findAll(pageable)
    expect(firstPage).toBeDefined()
    for await(const page of firstPage){
        // @ts-ignore
        elementsFound += page.content.length
    }
    expect(elementsFound, `Should have found ${numberToExpect} Entities`).toBe(numberToExpect)
}

export async function findAndVerifyPeopleWithOffsetPaging(entityService: IEntityService<Person>,
                                                          numberToExpect: number){
    let elementsFound = 0
    const pageable = Pageable.create(0,
                                               10,
                                               { orders: [
                                                       new Order('firstName', Direction.ASC),
                                                       new Order('id', Direction.ASC)
                                                   ] })
    const firstPage: IterablePage<Person> = await entityService.findAll(pageable)
    expect(firstPage).toBeDefined()
    for await(const page of firstPage){
        // @ts-ignore
        elementsFound += page.content.length
    }
    expect(elementsFound, `Should have found ${numberToExpect} Entities`).toBe(numberToExpect)
}

export function createTestPerson(index: number = 0): Person {
    const ret = new Person()
    ret.id = null
    if(index % 2 === 0){
        ret.firstName = 'John'
        ret.lastName = 'Doe'
    }else{
        ret.firstName = 'Steve'
        ret.lastName = 'Wozniak'
    }
//    ret.age = 42
    ret.address = {
        street: '123 Main St',
        city: 'Anytown',
        state: 'CA',
        zip: '12345'
    }
    return ret
}

export function generateRandomString(length: number){
    let result = ''
    const characters =
              'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
    const charactersLength = characters.length
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength))
    }
    return result
}

/**
 * Logs the failure of a promise and then rethrows the error
 * @param promise to log failure of
 * @param message to log
 */
export async function logFailure<T>(promise: Promise<T>, message: string): Promise<T> {
    try {
        return await promise
    } catch (e) {
        console.error(message, e)
        throw e
    }
}
